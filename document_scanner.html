<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Document Scanner</title>
<script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box;}
html,body{height:100%;overflow:hidden;}
body{font-family:'Segoe UI',sans-serif;background:#111;color:#fff;display:flex;flex-direction:column;}

/* ‚îÄ‚îÄ TOP BAR ‚îÄ‚îÄ */
.topbar{
  background:#1a2a4a;
  padding:10px 14px;
  display:flex;align-items:center;justify-content:space-between;
  flex-shrink:0;
}
.topbar h1{font-size:15px;font-weight:700;}
.topbar a{color:rgba(255,255,255,.6);font-size:11px;text-decoration:none;}

/* ‚îÄ‚îÄ MAIN PREVIEW ‚îÄ‚îÄ */
.preview-area{
  flex:1;
  position:relative;
  overflow:hidden;
  background:#1a1a1a;
  display:flex;align-items:center;justify-content:center;
}
/* Empty state */
.empty-state{
  display:flex;flex-direction:column;align-items:center;gap:16px;
  opacity:.5;
}
.empty-state svg{width:64px;height:64px;fill:#fff;}
.empty-state p{font-size:13px;}

/* Big page preview */
#bigPreview{
  max-width:100%;max-height:100%;
  object-fit:contain;
  display:none;
  user-select:none;
  -webkit-user-drag:none;
}

/* Page counter badge */
#pgBadge{
  position:absolute;top:10px;left:10px;
  background:rgba(0,0,0,.65);color:#fff;
  font-size:11px;font-weight:700;
  padding:4px 10px;border-radius:20px;
  display:none;
}

/* Prev / Next arrows */
.nav-btn{
  position:absolute;top:50%;transform:translateY(-50%);
  background:rgba(0,0,0,.5);border:none;color:#fff;
  width:36px;height:60px;border-radius:6px;
  font-size:20px;cursor:pointer;display:none;
  align-items:center;justify-content:center;
}
#btnPrev{left:4px;}
#btnNext{right:4px;}

/* ‚îÄ‚îÄ THUMBNAIL STRIP ‚îÄ‚îÄ */
.strip{
  height:72px;
  background:#0d1b35;
  display:flex;align-items:center;
  gap:6px;padding:6px 8px;
  overflow-x:auto;
  flex-shrink:0;
  -webkit-overflow-scrolling:touch;
}
.strip:empty::after{content:'No pages yet';color:rgba(255,255,255,.3);font-size:11px;margin:auto;}
.thumb{
  position:relative;flex-shrink:0;
  width:44px;height:60px;
  border-radius:4px;overflow:hidden;
  border:2px solid transparent;
  cursor:pointer;
}
.thumb.active{border-color:#27ae60;}
.thumb img{width:100%;height:100%;object-fit:cover;}
.thumb .t-num{
  position:absolute;bottom:0;left:0;right:0;
  background:rgba(0,0,0,.6);color:#fff;
  font-size:8px;font-weight:700;text-align:center;padding:2px;
}
/* Add button in strip */
.thumb-add{
  flex-shrink:0;width:44px;height:60px;border-radius:4px;
  background:rgba(255,255,255,.1);border:1.5px dashed rgba(255,255,255,.3);
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  cursor:pointer;color:rgba(255,255,255,.6);font-size:20px;gap:2px;
}
.thumb-add span{font-size:8px;}

/* ‚îÄ‚îÄ BOTTOM TOOLBAR ‚îÄ‚îÄ */
.toolbar{
  background:#1a2a4a;
  padding:8px 10px;
  display:flex;align-items:center;justify-content:space-around;
  flex-shrink:0;
  gap:6px;
}
.tbtn{
  flex:1;
  padding:9px 4px;
  background:rgba(255,255,255,.08);
  border:none;border-radius:8px;
  color:#fff;font-size:11px;font-weight:600;
  cursor:pointer;
  display:flex;flex-direction:column;align-items:center;gap:3px;
}
.tbtn .ico{font-size:18px;line-height:1;}
.tbtn:disabled{opacity:.3;}
.tbtn.primary{background:#27ae60;}
.tbtn.green{background:#27ae60;}

/* ‚îÄ‚îÄ EDITOR MODAL ‚îÄ‚îÄ */
#edModal{
  display:none;position:fixed;inset:0;z-index:9999;
  background:#000;flex-direction:column;
}
#edModal.open{display:flex;}
.ed-hdr{
  background:#1a2a4a;padding:8px 12px;
  display:flex;align-items:center;justify-content:space-between;
  flex-shrink:0;
}
.ed-hdr span{font-size:13px;font-weight:600;}
.ed-hdr button{background:none;border:none;color:#fff;font-size:26px;cursor:pointer;line-height:1;}
.ed-tools{
  background:#0d1b35;padding:7px 8px;
  display:flex;gap:5px;flex-wrap:wrap;flex-shrink:0;
}
.etbtn{
  padding:7px 11px;border:1.5px solid rgba(255,255,255,.3);
  border-radius:6px;font-size:12px;font-weight:600;
  cursor:pointer;background:transparent;color:#fff;white-space:nowrap;
}
.etbtn.on{background:#27ae60;border-color:#27ae60;}
.ed-canvas-area{
  flex:1;position:relative;overflow:hidden;
  background:#111;display:flex;align-items:center;justify-content:center;
}
#ec{display:block;position:absolute;touch-action:none;max-width:100%;max-height:100%;}
.ed-ftr{
  background:#1a2a4a;padding:8px 12px;
  display:flex;gap:8px;justify-content:space-between;flex-shrink:0;
}

/* ‚îÄ‚îÄ PDF MODAL ‚îÄ‚îÄ */
#pdfModal{
  display:none;position:fixed;inset:0;z-index:9998;
  background:rgba(0,0,0,.7);align-items:flex-end;
}
#pdfModal.open{display:flex;}
.pdf-sheet{
  background:#1a2a4a;border-radius:16px 16px 0 0;
  padding:20px 16px 32px;width:100%;
}
.pdf-sheet h3{font-size:14px;font-weight:700;margin-bottom:16px;}
.pdf-sheet input{
  width:100%;padding:10px 12px;border-radius:8px;
  border:2px solid rgba(255,255,255,.2);background:rgba(255,255,255,.1);
  color:#fff;font-size:14px;margin-bottom:12px;outline:none;
}
.q-row{display:flex;gap:6px;margin-bottom:16px;}
.q-btn{
  flex:1;padding:8px 4px;font-size:11px;border-radius:6px;
  border:1.5px solid rgba(255,255,255,.3);background:transparent;
  color:#fff;cursor:pointer;font-weight:600;text-align:center;
}
.q-btn.active{background:#27ae60;border-color:#27ae60;}
.pdf-btns{display:flex;gap:8px;}
.pdf-btns button{flex:1;padding:12px;border:none;border-radius:8px;font-size:14px;font-weight:700;cursor:pointer;}
.pdf-cancel{background:rgba(255,255,255,.15);color:#fff;}
.pdf-go{background:#27ae60;color:#fff;}
.st{padding:9px;border-radius:7px;font-size:12px;font-weight:600;text-align:center;margin-top:10px;display:none;}
.st.show{display:block;}
.st.ok{background:#d4edda;color:#155724;}
.st.err{background:#f8d7da;color:#721c24;}
.st.info{background:#d1ecf1;color:#0c5460;}



/* Generic small btn */
.gbtn{
  padding:6px 12px;border:none;border-radius:6px;
  font-size:11px;font-weight:600;cursor:pointer;
}
.gbtn-danger{background:#c0392b;color:#fff;}
.gbtn-light{background:rgba(255,255,255,.15);color:#fff;}
#redactBar{display:none;}
#redactBar.show{display:flex;}
</style>
</head>
<body>

<!-- TOP BAR -->
<div class="topbar">
  <h1>üìÑ Document Scanner</h1>
  <a href="index.html">‚Üê Home</a>
</div>

<!-- MAIN PREVIEW -->
<div class="preview-area" id="previewArea">
  <div class="empty-state" id="emptyState">
    <svg viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6zm-1 1.5L18.5 9H13V3.5zM6 20V4h5v7h7v9H6z"/></svg>
    <p>Tap + to add pages</p>
  </div>
  <img id="bigPreview" alt="page preview">
  <div id="pgBadge"></div>
  <button class="nav-btn" id="btnPrev" onclick="navigate(-1)">‚Äπ</button>
  <button class="nav-btn" id="btnNext" onclick="navigate(1)">‚Ä∫</button>
</div>

<!-- THUMBNAIL STRIP -->
<div class="strip" id="strip"></div>

<!-- BOTTOM TOOLBAR -->
<div class="toolbar">
  <button class="tbtn" id="tbAdd" onclick="triggerAdd()">
    <span class="ico">‚ûï</span><span>Add</span>
  </button>
  <button class="tbtn" id="tbDel" onclick="delCurrent()" disabled>
    <span class="ico">üóë</span><span>Delete</span>
  </button>
  <button class="tbtn" id="tbEdit" onclick="openEd(curIdx)" disabled>
    <span class="ico">‚úèÔ∏è</span><span>Edit</span>
  </button>
  <button class="tbtn" id="tbRotate" onclick="rotateCurrent()" disabled>
    <span class="ico">‚Üª</span><span>Rotate</span>
  </button>
  <button class="tbtn green" id="tbPDF" onclick="openPDFModal()" disabled>
    <span class="ico">üìÑ</span><span>PDF</span>
  </button>
</div>



<input type="file" id="fi" accept="image/*" multiple style="display:none" onchange="addPages(event)">

<!-- EDITOR MODAL -->
<div id="edModal">
  <div class="ed-hdr">
    <span id="edTitle">Edit</span>
    <button onclick="closeEd()">√ó</button>
  </div>
  <div class="ed-tools">
    <button class="etbtn" id="tCrop"   onclick="setTool('crop')">‚úÇÔ∏è Crop</button>
    <button class="etbtn" id="tRedact" onclick="setTool('redact')">üñå Brush</button>
    <button class="etbtn" id="tRedactRect" onclick="setTool('redactRect')">‚¨ú Box</button>
    <button class="etbtn"              onclick="rotImg(90)">‚Üª Rotate</button>
    <button class="etbtn"              onclick="autoCrop()">üî≤ Auto</button>
  </div>
  <div id="redactBar" style="display:none;background:#0d1b35;padding:6px 14px;align-items:center;gap:10px;flex-shrink:0;">
    <span style="color:#fff;font-size:11px;white-space:nowrap;">üñå</span>
    <input type="range" id="brushSize" min="4" max="100" value="20"
      style="flex:1;accent-color:#27ae60;"
      oninput="brushRadius=parseInt(this.value);document.getElementById('brushSizeVal').textContent=this.value">
    <span id="brushSizeVal" style="color:#fff;font-size:11px;min-width:28px;text-align:right">20px</span>
    <button onclick="document.getElementById('redactBar').style.display='none'" style="background:none;border:none;color:rgba(255,255,255,.5);font-size:16px;cursor:pointer;padding:0 4px">‚úï</button>
  </div>
  <div class="ed-canvas-area" id="edCanvasArea">
    <canvas id="ec"></canvas>
  </div>
  <div class="ed-ftr">
    <div style="display:flex;gap:6px">
      <button class="gbtn gbtn-light" onclick="undoEd()">‚Ü© Undo</button>
      <button class="gbtn gbtn-light" onclick="resetEd()">‚Ü∫ Reset</button>
    </div>
    <div style="display:flex;gap:6px">
      <button class="gbtn gbtn-light" onclick="closeEd()">Cancel</button>
      <button class="gbtn" style="background:#27ae60;color:#fff" onclick="applyEd()">‚úì Apply</button>
    </div>
  </div>
</div>

<!-- PDF MODAL -->
<div id="pdfModal" onclick="if(event.target===this)closePDFModal()">
  <div class="pdf-sheet">
    <h3>üìÑ Export PDF</h3>
    <input type="text" id="pdfName" value="document" placeholder="File name">
    <div class="q-row">
      <div class="q-btn active" data-q="0.6" onclick="setQ(this)">Small</div>
      <div class="q-btn" data-q="0.8" onclick="setQ(this)">Medium</div>
      <div class="q-btn" data-q="0.92" onclick="setQ(this)">High</div>
      <div class="q-btn" data-q="1" onclick="setQ(this)">Full</div>
    </div>
    <div class="pdf-btns">
      <button class="pdf-cancel" onclick="closePDFModal()">Cancel</button>
      <button class="pdf-go" onclick="exportPDF()">Generate & Download</button>
    </div>
    <div class="st" id="pdfSt"></div>
  </div>
</div>



<script>
if(sessionStorage.getItem('bulut_auth')!=='1') window.location.href='index.html';

/* ‚ïê‚ïê‚ïê STATE ‚ïê‚ïê‚ïê */
const pages = [];
let curIdx  = null;
let pdfQ    = 0.6;
let tReady  = false;

/* ‚ïê‚ïê‚ïê EXIF + AUTO-ROTATE ‚ïê‚ïê‚ïê */
function applyOrientation(img, ori, cb){
  const c=document.createElement('canvas'), ctx=c.getContext('2d');
  const w=img.width, h=img.height;
  if(ori>=5&&ori<=8){c.width=h;c.height=w;}
  else{c.width=w;c.height=h;}
  switch(ori){
    case 2:ctx.translate(w,0);ctx.scale(-1,1);break;
    case 3:ctx.translate(w,h);ctx.rotate(Math.PI);break;
    case 4:ctx.translate(0,h);ctx.scale(1,-1);break;
    case 5:ctx.rotate(.5*Math.PI);ctx.scale(1,-1);break;
    case 6:ctx.rotate(.5*Math.PI);ctx.translate(0,-h);break;
    case 7:ctx.rotate(.5*Math.PI);ctx.translate(w,-h);ctx.scale(-1,1);break;
    case 8:ctx.rotate(-.5*Math.PI);ctx.translate(-w,0);break;
  }
  ctx.drawImage(img,0,0,w,h);
  cb(c.toDataURL('image/jpeg',0.92));
}

function autoRotLeft(dataUrl, quality, cb){
  const img=new Image();
  img.onload=()=>{
    // Apply max dimension based on quality setting
    const maxDims={0.6:1200, 0.8:1800, 0.92:2400, 1:99999};
    const maxD=maxDims[quality]||1800;
    let sw=img.height, sh=img.width; // after 90¬∞ rotation width/height swap
    if(sw>maxD){sh=Math.round(sh*maxD/sw);sw=maxD;}
    if(sh>maxD){sw=Math.round(sw*maxD/sh);sh=maxD;}
    const c=document.createElement('canvas');
    c.width=sw; c.height=sh;
    const ctx=c.getContext('2d');
    ctx.translate(c.width/2,c.height/2);
    ctx.rotate(-Math.PI/2);
    // draw original (img.width x img.height) scaled to fit
    const scaleX=sh/img.width, scaleY=sw/img.height;
    ctx.scale(scaleX,scaleY);
    ctx.drawImage(img,-img.width/2,-img.height/2);
    cb(c.toDataURL('image/jpeg',quality>=1?0.95:quality));
  };
  img.src=dataUrl;
}

function loadAndFix(file, cb){
  const r=new FileReader();
  r.onload=e=>{
    const img=new Image();
    img.onload=()=>{
      try{
        EXIF.getData(img,function(){
          const ori=EXIF.getTag(this,'Orientation')||1;
          applyOrientation(img,ori,fixed=>{
            autoRotLeft(fixed,pdfQ,cb);
          });
        });
      }catch(err){
        autoRotLeft(e.target.result,pdfQ,cb);
      }
    };
    img.src=e.target.result;
  };
  r.readAsDataURL(file);
}

/* ‚ïê‚ïê‚ïê PAGE MANAGEMENT ‚ïê‚ïê‚ïê */
function triggerAdd(){
  const f=document.getElementById('fi');
  f.removeAttribute('capture');
  f.value=''; f.click();
}
function delCurrent(){
  if(curIdx===null||!pages.length) return;
  pages.splice(curIdx,1);
  if(pages.length===0){ curIdx=null; showEmpty(); }
  else{ curIdx=Math.min(curIdx,pages.length-1); selectPage(curIdx); }
  renderStrip();
  updateUI();
}
function showEmpty(){
  document.getElementById('bigPreview').style.display='none';
  const es=document.getElementById('emptyState');
  es.innerHTML='<svg viewBox="0 0 24 24" style="width:64px;height:64px;fill:#fff"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6zm-1 1.5L18.5 9H13V3.5zM6 20V4h5v7h7v9H6z"/></svg><p>Tap + to add pages</p>';
  es.style.display='flex';
  document.getElementById('pgBadge').style.display='none';
  document.getElementById('btnPrev').style.display='none';
  document.getElementById('btnNext').style.display='none';
}

function addPages(ev){
  const files=Array.from(ev.target.files); ev.target.value='';
  if(!files.length)return;
  // Process all files in parallel
  const results=new Array(files.length).fill(null);
  let done=0;
  files.forEach((f,i)=>{
    loadAndFix(f,url=>{
      results[i]=url;
      if(++done===files.length){
        // Add in original order
        results.forEach(url=>pages.push({orig:url,cur:url}));
        selectPage(pages.length-1);
        renderStrip();
        updateUI();
      }
    });
  });
}

function selectPage(idx){
  if(idx<0||idx>=pages.length)return;
  curIdx=idx;
  const bp=document.getElementById('bigPreview');
  bp.src=pages[idx].cur;
  bp.style.display='block';
  document.getElementById('emptyState').style.display='none';
  document.getElementById('pgBadge').textContent=(idx+1)+' / '+pages.length;
  document.getElementById('pgBadge').style.display='block';
  // nav arrows
  document.getElementById('btnPrev').style.display=idx>0?'flex':'none';
  document.getElementById('btnNext').style.display=idx<pages.length-1?'flex':'none';
  // highlight strip
  document.querySelectorAll('.thumb').forEach((t,i)=>t.classList.toggle('active',i===idx));
  updateUI();
}

function navigate(dir){
  if(curIdx===null)return;
  selectPage(curIdx+dir);
}

function rotateCurrent(){
  if(curIdx===null)return;
  const src=pages[curIdx].cur;
  const img=new Image();
  img.onload=()=>{
    const c=document.createElement('canvas');
    c.width=img.height; c.height=img.width;
    const ctx=c.getContext('2d');
    ctx.translate(c.width/2,c.height/2);
    ctx.rotate(Math.PI/2);
    ctx.drawImage(img,-img.width/2,-img.height/2);
    const url=c.toDataURL('image/jpeg',pdfQ);
    pages[curIdx]={orig:url,cur:url};
    selectPage(curIdx);
    renderStrip();
  };
  img.src=src;
}

// Drag-sort state
let dragSrcIdx=null;

function renderStrip(){
  const strip=document.getElementById('strip');
  strip.innerHTML='';
  pages.forEach((pg,idx)=>{
    const t=document.createElement('div');
    t.className='thumb'+(idx===curIdx?' active':'');
    t.onclick=()=>{ if(!dragSrcIdx&&dragSrcIdx!==0) selectPage(idx); };

    // Drag sort ‚Äî mouse
    t.draggable=true;
    t.addEventListener('dragstart',e=>{
      dragSrcIdx=idx;
      t.style.opacity='0.4';
      e.dataTransfer.effectAllowed='move';
    });
    t.addEventListener('dragend',e=>{ t.style.opacity=''; dragSrcIdx=null; });
    t.addEventListener('dragover',e=>{ e.preventDefault(); e.dataTransfer.dropEffect='move'; });
    t.addEventListener('dragenter',e=>{ t.style.outline='2px solid #27ae60'; });
    t.addEventListener('dragleave',e=>{ t.style.outline=''; });
    t.addEventListener('drop',e=>{
      e.preventDefault(); t.style.outline='';
      if(dragSrcIdx===null||dragSrcIdx===idx) return;
      const moved=pages.splice(dragSrcIdx,1)[0];
      pages.splice(idx,0,moved);
      curIdx=idx; // follow the moved page
      renderStrip();
      selectPage(curIdx);
      dragSrcIdx=null;
    });

    // Drag sort ‚Äî touch
    let touchDragTimer=null, touchDragActive=false, touchDragClone=null;
    t.addEventListener('touchstart',e=>{
      touchDragTimer=setTimeout(()=>{
        touchDragActive=true;
        dragSrcIdx=idx;
        // Create visual clone
        touchDragClone=t.cloneNode(true);
        touchDragClone.style.cssText='position:fixed;z-index:9999;opacity:0.7;pointer-events:none;width:44px;height:60px;border-radius:4px;overflow:hidden;';
        document.body.appendChild(touchDragClone);
        t.style.opacity='0.3';
      },400);
    },{passive:true});
    t.addEventListener('touchmove',e=>{
      if(!touchDragActive) return;
      e.preventDefault();
      const touch=e.touches[0];
      if(touchDragClone){
        touchDragClone.style.left=(touch.clientX-22)+'px';
        touchDragClone.style.top=(touch.clientY-30)+'px';
      }
      // Find target thumb under finger
      document.querySelectorAll('.thumb').forEach((el,i)=>{
        const r=el.getBoundingClientRect();
        el.style.outline=(touch.clientX>=r.left&&touch.clientX<=r.right&&touch.clientY>=r.top&&touch.clientY<=r.bottom&&i!==dragSrcIdx)?'2px solid #27ae60':'';
      });
    },{passive:false});
    t.addEventListener('touchend',e=>{
      clearTimeout(touchDragTimer);
      if(touchDragClone){touchDragClone.remove();touchDragClone=null;}
      t.style.opacity='';
      document.querySelectorAll('.thumb').forEach(el=>el.style.outline='');
      if(!touchDragActive){ touchDragActive=false; dragSrcIdx=null; return; }
      touchDragActive=false;
      const touch=e.changedTouches[0];
      let targetIdx=null;
      document.querySelectorAll('.thumb').forEach((el,i)=>{
        const r=el.getBoundingClientRect();
        if(touch.clientX>=r.left&&touch.clientX<=r.right&&touch.clientY>=r.top&&touch.clientY<=r.bottom) targetIdx=i;
      });
      if(targetIdx!==null&&targetIdx!==dragSrcIdx){
        const moved=pages.splice(dragSrcIdx,1)[0];
        pages.splice(targetIdx,0,moved);
        curIdx=targetIdx;
        renderStrip();
        selectPage(curIdx);
      }
      dragSrcIdx=null;
    },{passive:true});

    const img=document.createElement('img');
    img.src=pg.cur;
    const num=document.createElement('div');
    num.className='t-num'; num.textContent=idx+1;
    t.append(img,num);
    strip.appendChild(t);
  });
  // Add button
  const add=document.createElement('div');
  add.className='thumb-add';
  add.innerHTML='<span style="font-size:22px">+</span><span>Add</span>';
  add.onclick=()=>triggerAdd();
  strip.appendChild(add);
}

function updateUI(){
  const has=pages.length>0;
  const hasSel=curIdx!==null;
  document.getElementById('tbDel').disabled=!hasSel;
  document.getElementById('tbEdit').disabled=!hasSel;
  document.getElementById('tbRotate').disabled=!hasSel;
  document.getElementById('tbPDF').disabled=!has;
}

/* ‚ïê‚ïê‚ïê EDITOR ‚ïê‚ïê‚ïê */
let edIdx=null, edW, edH, edSc;
let tool='crop', history=[], cropRect=null;
// quad = {tl,tr,bl,br} ‚Äî 4 free-moving corners for skewed crop
let quad=null;
let brushRadius=20;
let panStart=null, quadAtPanStart=null; // for dragging whole quad
let drawing=false, px0,py0,px1,py1, dragCorner=null, dragEdge=null, pinch0=null;
// Viewport pan+zoom (for canvas element positioning)
let vZ=1, vX=0, vY=0; // zoom, translateX, translateY
let pinchMidX=0, pinchMidY=0; // midpoint of pinch gesture
let vpanStart=null, vXatPan=0, vYatPan=0; // 1-finger canvas pan (when no tool active)
const edModal=document.getElementById('edModal');
const ec=document.getElementById('ec');
const ectx=ec.getContext('2d');

function openEd(idx){
  if(idx===null||idx===undefined)return;
  edIdx=idx; history=[]; cropRect=null; quad=null; tool='none'; vZ=1; vX=0; vY=0;
  document.querySelectorAll('.etbtn').forEach(b=>b.classList.remove('on'));
  tool='none';
  document.getElementById('edTitle').textContent='Edit ‚Äî Page '+(idx+1);
  edModal.classList.add('open');

  // Wait for modal to be visible so clientWidth/Height are correct
  requestAnimationFrame(()=>{
    requestAnimationFrame(()=>{
      const img=new Image();
      img.onload=()=>{
        edW=img.width; edH=img.height;
        fitCanvas();
        ectx.drawImage(img,0,0,ec.width,ec.height);
        history.push(ec.toDataURL('image/jpeg',0.92));
      };
      img.src=pages[edIdx].cur;
    });
  });
}

function fitCanvas(){
  const area=document.getElementById('edCanvasArea');
  const ww=area.clientWidth, wh=area.clientHeight;
  ec.width  = edW;
  ec.height = edH;
  edSc = Math.min((ww-8)/edW, (wh-8)/edH, 1);
  const dispW = Math.round(edW * edSc);
  const dispH = Math.round(edH * edSc);
  ec.style.width  = dispW + 'px';
  ec.style.height = dispH + 'px';
  // Reset viewport
  vZ=1; vX=0; vY=0;
  applyViewport();
}
function applyViewport(){
  const area=document.getElementById('edCanvasArea');
  const ww=area.clientWidth, wh=area.clientHeight;
  const dispW=parseFloat(ec.style.width)||ec.width*edSc;
  const dispH=parseFloat(ec.style.height)||ec.height*edSc;
  const baseL=Math.round((ww-dispW)/2);
  const baseT=Math.round((wh-dispH)/2);
  ec.style.left=(baseL+vX)+'px';
  ec.style.top =(baseT+vY)+'px';
  ec.style.transform='scale('+vZ+')';
  ec.style.transformOrigin='top left';
}

function redrawEc(srcOverride){
  const src=srcOverride||(history.length?history[history.length-1]:null)||pages[edIdx].cur;
  const img=new Image();
  img.onload=()=>{
    ectx.clearRect(0,0,ec.width,ec.height);
    ectx.drawImage(img,0,0,ec.width,ec.height);
    drawCropOverlay();
    if(tool==='redactRect') drawRRect();
  };
  img.src=src;
}

function rectToQuad(x,y,w,h){
  return{tl:{x,y},tr:{x:x+w,y},bl:{x,y:y+h},br:{x:x+w,y:y+h}};
}
function drawCropOverlay(){
  if(!quad)return;
  const{tl,tr,bl,br}=quad;
  const lw=Math.max(2,3/edSc);
  const navy='#000000';

  // ‚îÄ‚îÄ Border: thin solid navy line with white glow underneath ‚îÄ‚îÄ
  ectx.save();
  // White glow / outline
  ectx.strokeStyle='rgba(255,255,255,0.7)';
  ectx.lineWidth=lw+4; ectx.setLineDash([]);
  ectx.beginPath();
  ectx.moveTo(tl.x,tl.y);ectx.lineTo(tr.x,tr.y);
  ectx.lineTo(br.x,br.y);ectx.lineTo(bl.x,bl.y);
  ectx.closePath();ectx.stroke();
  // Navy border
  ectx.strokeStyle=navy;
  ectx.lineWidth=lw+1; ectx.setLineDash([]);
  ectx.beginPath();
  ectx.moveTo(tl.x,tl.y);ectx.lineTo(tr.x,tr.y);
  ectx.lineTo(br.x,br.y);ectx.lineTo(bl.x,bl.y);
  ectx.closePath();ectx.stroke();
  ectx.restore();

  // ‚îÄ‚îÄ Corner handles: hollow circle, navy stroke, transparent fill ‚îÄ‚îÄ
  const cr=Math.max(10,14/edSc);
  [tl,tr,bl,br].forEach(p=>{
    ectx.save();
    // White backing
    ectx.strokeStyle='rgba(255,255,255,0.8)';
    ectx.lineWidth=Math.max(2,4/edSc)+2;
    ectx.beginPath();ectx.arc(p.x,p.y,cr,0,Math.PI*2);ectx.stroke();
    // Navy ring
    ectx.strokeStyle=navy;
    ectx.lineWidth=Math.max(2,4/edSc);
    ectx.beginPath();ectx.arc(p.x,p.y,cr,0,Math.PI*2);ectx.stroke();
    ectx.restore();
  });

  // ‚îÄ‚îÄ Edge midpoint handles: hollow rounded rect, navy stroke ‚îÄ‚îÄ
  const edges=[
    {a:tl,b:tr},  // top
    {a:tr,b:br},  // right
    {a:bl,b:br},  // bottom
    {a:tl,b:bl},  // left
  ];
  const rw=Math.max(20,28/edSc), rh=Math.max(10,14/edSc);
  edges.forEach(({a,b})=>{
    const mx=(a.x+b.x)/2, my=(a.y+b.y)/2;
    // Angle of edge
    const angle=Math.atan2(b.y-a.y,b.x-a.x);
    ectx.save();
    ectx.translate(mx,my);ectx.rotate(angle);
    // White backing
    ectx.strokeStyle='rgba(255,255,255,0.8)';
    ectx.lineWidth=Math.max(2,3/edSc)+2;
    ectx.beginPath();
    roundRect(ectx,-rw/2,-rh/2,rw,rh,rh/2);
    ectx.stroke();
    // Navy
    ectx.strokeStyle=navy;
    ectx.lineWidth=Math.max(2,3/edSc);
    ectx.beginPath();
    roundRect(ectx,-rw/2,-rh/2,rw,rh,rh/2);
    ectx.stroke();
    ectx.restore();
  });

  // ‚îÄ‚îÄ Center move handle: hollow circle + crosshair ‚îÄ‚îÄ
  const ccx=(tl.x+tr.x+bl.x+br.x)/4;
  const ccy=(tl.y+tr.y+bl.y+br.y)/4;
  const ccr=Math.max(18,24/edSc);
  ectx.save();
  ectx.strokeStyle='rgba(255,255,255,0.8)';
  ectx.lineWidth=Math.max(2,4/edSc)+2;
  ectx.beginPath();ectx.arc(ccx,ccy,ccr,0,Math.PI*2);ectx.stroke();
  ectx.strokeStyle=navy;
  ectx.lineWidth=Math.max(2,3/edSc);
  ectx.beginPath();ectx.arc(ccx,ccy,ccr,0,Math.PI*2);ectx.stroke();
  // crosshair
  const arm=ccr*0.55;
  ectx.beginPath();
  ectx.moveTo(ccx-arm,ccy);ectx.lineTo(ccx+arm,ccy);
  ectx.moveTo(ccx,ccy-arm);ectx.lineTo(ccx,ccy+arm);
  ectx.stroke();
  ectx.restore();
}

function roundRect(ctx,x,y,w,h,r){
  ctx.moveTo(x+r,y);
  ctx.lineTo(x+w-r,y);ctx.arcTo(x+w,y,x+w,y+r,r);
  ctx.lineTo(x+w,y+h-r);ctx.arcTo(x+w,y+h,x+w-r,y+h,r);
  ctx.lineTo(x+r,y+h);ctx.arcTo(x,y+h,x,y+h-r,r);
  ctx.lineTo(x,y+r);ctx.arcTo(x,y,x+r,y,r);
  ctx.closePath();
}

function setTool(t){
  if(tool===t){
    tool='none'; rRect=null;
    document.querySelectorAll('.etbtn').forEach(b=>b.classList.remove('on'));
    document.getElementById('redactBar').style.display='none';
    redrawEc(); return;
  }
  tool=t; rRect=null;
  document.querySelectorAll('.etbtn').forEach(b=>b.classList.remove('on'));
  const btnId='t'+t.charAt(0).toUpperCase()+t.slice(1);
  const btn=document.getElementById(btnId);
  if(btn) btn.classList.add('on');
  document.getElementById('redactBar').style.display=(t==='redact')?'flex':'none';
}

function closeEd(){edModal.classList.remove('open');}

function undoEd(){
  if(history.length<=1)return;
  history.pop();
  cropRect=null; quad=null; rRect=null;
  redrawEc();
}

function resetEd(){
  history=[];cropRect=null;quad=null;
  const img=new Image();
  img.onload=()=>{
    edW=img.width;edH=img.height;fitCanvas();
    ectx.drawImage(img,0,0,ec.width,ec.height);
    history.push(ec.toDataURL('image/jpeg',0.92));
  };
  img.src=pages[edIdx].orig;
}

function rotImg(deg){
  const src=history[history.length-1]||pages[edIdx].cur;
  const img=new Image();
  img.onload=()=>{
    const c=document.createElement('canvas');
    if(Math.abs(deg)===90){c.width=img.height;c.height=img.width;}
    else{c.width=img.width;c.height=img.height;}
    const ctx=c.getContext('2d');
    ctx.translate(c.width/2,c.height/2);
    ctx.rotate(deg*Math.PI/180);
    ctx.drawImage(img,-img.width/2,-img.height/2);
    const url=c.toDataURL('image/jpeg',0.92);
    history.push(url);
    edW=c.width;edH=c.height;
    fitCanvas();
    const ni=new Image();
    ni.onload=()=>{ectx.clearRect(0,0,ec.width,ec.height);ectx.drawImage(ni,0,0,ec.width,ec.height);};
    ni.src=url;cropRect=null;
  };
  img.src=src;
}

function autoCrop(){
  setTool('crop');
  const src=history[history.length-1]||pages[edIdx].cur;
  const img=new Image();
  img.onload=()=>{
    const c=document.createElement('canvas');
    c.width=img.width;c.height=img.height;
    const ctx=c.getContext('2d');ctx.drawImage(img,0,0);
    const d=ctx.getImageData(0,0,c.width,c.height).data;
    const bgR=d[0],bgG=d[1],bgB=d[2];
    let mnX=c.width,mnY=c.height,mxX=0,mxY=0;
    for(let y=0;y<c.height;y++)for(let x=0;x<c.width;x++){
      const i=(y*c.width+x)*4;
      if(Math.abs(d[i]-bgR)+Math.abs(d[i+1]-bgG)+Math.abs(d[i+2]-bgB)>80){
        if(x<mnX)mnX=x;if(y<mnY)mnY=y;if(x>mxX)mxX=x;if(y>mxY)mxY=y;
      }
    }
    const pad=20; // extra inset so handles aren't right at edge
    mnX=Math.max(0,mnX+pad);mnY=Math.max(0,mnY+pad);
    mxX=Math.min(c.width,mxX-pad);mxY=Math.min(c.height,mxY-pad);
    if(mxX-mnX>20&&mxY-mnY>20){
      quad=rectToQuad(mnX,mnY,mxX-mnX,mxY-mnY);
      cropRect=null;
      redrawEc();
    }
  };
  img.src=src;
}

function applyEd(){
  // commit any pending rect redact first
  if(rRect){ commitRRect(); return; } // commitRRect will call redrawEc, user presses Apply again for crop
  const src=history[history.length-1]||pages[edIdx].cur;
  const img=new Image();
  img.onload=()=>{
    let c=document.createElement('canvas');
    c.width=img.width;c.height=img.height;
    c.getContext('2d').drawImage(img,0,0);
    if(quad){
      // Bounding box of quad
      const{tl,tr,bl,br}=quad;
      const xs=[tl.x,tr.x,bl.x,br.x],ys=[tl.y,tr.y,bl.y,br.y];
      const mnX=Math.max(0,Math.round(Math.min(...xs)));
      const mnY=Math.max(0,Math.round(Math.min(...ys)));
      const mxX=Math.min(img.width,Math.round(Math.max(...xs)));
      const mxY=Math.min(img.height,Math.round(Math.max(...ys)));
      const cw=mxX-mnX,ch=mxY-mnY;
      if(cw>4&&ch>4){
        const cc=document.createElement('canvas');
        cc.width=cw;cc.height=ch;
        const cctx=cc.getContext('2d');
        // Clip to quad polygon (offset by bounding box)
        cctx.beginPath();
        cctx.moveTo(tl.x-mnX,tl.y-mnY);cctx.lineTo(tr.x-mnX,tr.y-mnY);
        cctx.lineTo(br.x-mnX,br.y-mnY);cctx.lineTo(bl.x-mnX,bl.y-mnY);
        cctx.closePath();cctx.clip();
        cctx.drawImage(c,-mnX,-mnY);
        c=cc;
      }
    }
    pages[edIdx].cur=c.toDataURL('image/jpeg',pdfQ);
    selectPage(edIdx);
    renderStrip();
    closeEd();
  };
  img.src=src;
}

/* ‚ïê‚ïê‚ïê CANVAS COORDS ‚ïê‚ïê‚ïê */
function canvasPt(clientX,clientY){
  const r=ec.getBoundingClientRect();
  // getBoundingClientRect accounts for CSS transform+position
  const x=(clientX-r.left)*(ec.width/r.width);
  const y=(clientY-r.top)*(ec.height/r.height);
  return{x, y};
}
function nearQuadCorner(ix,iy){
  if(!quad)return null;
  const hs=Math.max(22,32/edSc);
  for(const name of['tl','tr','bl','br']){
    const p=quad[name];
    if(Math.hypot(ix-p.x,iy-p.y)<hs) return name;
  }
  return null;
}
// Returns edge name ('top','right','bottom','left') if near midpoint handle
function nearEdgeMid(ix,iy){
  if(!quad)return null;
  const hs=Math.max(22,32/edSc);
  const{tl,tr,bl,br}=quad;
  const mids={
    top:   {x:(tl.x+tr.x)/2, y:(tl.y+tr.y)/2},
    right: {x:(tr.x+br.x)/2, y:(tr.y+br.y)/2},
    bottom:{x:(bl.x+br.x)/2, y:(bl.y+br.y)/2},
    left:  {x:(tl.x+bl.x)/2, y:(tl.y+bl.y)/2},
  };
  for(const[name,p] of Object.entries(mids)){
    if(Math.hypot(ix-p.x,iy-p.y)<hs) return name;
  }
  return null;
}
// Move an edge by shifting both its corner points perpendicularly
function moveEdgeMid(edgeName, ix, iy){
  if(!quad)return;
  const{tl,tr,bl,br}=quad;
  if(edgeName==='top'){
    // top edge: tl+tr move to follow finger Y (keep X)
    const dy=iy-(tl.y+tr.y)/2;
    quad.tl={x:tl.x,y:tl.y+dy};
    quad.tr={x:tr.x,y:tr.y+dy};
  } else if(edgeName==='bottom'){
    const dy=iy-(bl.y+br.y)/2;
    quad.bl={x:bl.x,y:bl.y+dy};
    quad.br={x:br.x,y:br.y+dy};
  } else if(edgeName==='left'){
    const dx=ix-(tl.x+bl.x)/2;
    quad.tl={x:tl.x+dx,y:tl.y};
    quad.bl={x:bl.x+dx,y:bl.y};
  } else if(edgeName==='right'){
    const dx=ix-(tr.x+br.x)/2;
    quad.tr={x:tr.x+dx,y:tr.y};
    quad.br={x:br.x+dx,y:br.y};
  }
}
function isInsideQuad(ix,iy){
  if(!quad)return false;
  const{tl,tr,bl,br}=quad;
  // Simple point-in-polygon check
  const pts=[tl,tr,br,bl];
  let inside=false;
  for(let i=0,j=pts.length-1;i<pts.length;j=i++){
    const xi=pts[i].x,yi=pts[i].y,xj=pts[j].x,yj=pts[j].y;
    if(((yi>iy)!==(yj>iy))&&(ix<(xj-xi)*(iy-yi)/(yj-yi)+xi)) inside=!inside;
  }
  return inside;
}
function moveQuadCorner(name,ix,iy){
  if(!quad)return;
  quad[name]={x:ix,y:iy};
}
// Brush stroke: array of points collected during finger move
let brushPoints = [];
// Rect redact state
let rRect=null; // {x,y,w,h} in image coords
let rRectDragCorner=null, rRectPanStart=null, rRectAtPan=null;

function commitBrushStroke(){
  if(!brushPoints.length) return;
  // Snapshot points and radius NOW before any async ‚Äî prevents bug where
  // brushPoints get cleared before img.onload fires
  const pts=[...brushPoints];
  const r=brushRadius;
  brushPoints=[]; // clear immediately so next stroke starts fresh
  const src=history[history.length-1]||pages[edIdx].cur;
  const img=new Image();
  img.onload=()=>{
    const c=document.createElement('canvas');
    c.width=img.width;c.height=img.height;
    const ctx=c.getContext('2d');ctx.drawImage(img,0,0);
    ctx.strokeStyle='#ffffff';
    ctx.lineWidth=r*2;
    ctx.lineCap='round';
    ctx.lineJoin='round';
    ctx.beginPath();
    ctx.moveTo(pts[0][0],pts[0][1]);
    pts.forEach(([bx,by])=>ctx.lineTo(bx,by));
    ctx.stroke();
    ctx.fillStyle='#fff';
    [pts[0],pts[pts.length-1]].forEach(([bx,by])=>{
      ctx.beginPath();ctx.arc(bx,by,r,0,Math.PI*2);ctx.fill();
    });
    const newUrl=c.toDataURL('image/jpeg',0.92);
    history.push(newUrl);
    redrawEc(newUrl); // pass url directly ‚Äî avoids async race
  };
  img.src=src;
}

function drawBrushLive(ix,iy){
  const r=brushRadius;
  const prev=brushPoints.length>1?brushPoints[brushPoints.length-2]:null;
  if(prev){
    ectx.strokeStyle='#ffffff';
    ectx.lineWidth=r*2;ectx.lineCap='round';ectx.lineJoin='round';
    ectx.beginPath();ectx.moveTo(prev[0],prev[1]);ectx.lineTo(ix,iy);ectx.stroke();
  } else {
    ectx.fillStyle='#ffffff';
    ectx.beginPath();ectx.arc(ix,iy,r,0,Math.PI*2);ectx.fill();
  }
}
function drawRRect(){
  if(!rRect) return;
  const{x,y,w,h}=rRect;
  // Fill preview
  ectx.fillStyle='rgba(255,255,255,0.55)';
  ectx.fillRect(x,y,w,h);
  // Border
  ectx.strokeStyle='#ffffff';
  ectx.lineWidth=Math.max(2,3/edSc);
  ectx.setLineDash([8,4]);
  ectx.strokeRect(x,y,w,h);
  ectx.setLineDash([]);
  // Corners ‚Äî simple small squares, no decoration
  const cs=Math.max(8,12/edSc);
  [[x,y],[x+w,y],[x,y+h],[x+w,y+h]].forEach(([cx,cy])=>{
    ectx.fillStyle='#fff';
    ectx.fillRect(cx-cs/2,cy-cs/2,cs,cs);
  });
  // Center cross (move handle) ‚Äî shown only, apply removes it
  const ccx=x+w/2, ccy=y+h/2;
  const arm=Math.max(10,16/edSc);
  ectx.strokeStyle='rgba(255,255,255,0.8)';
  ectx.lineWidth=Math.max(1.5,2/edSc);
  ectx.beginPath();
  ectx.moveTo(ccx-arm,ccy);ectx.lineTo(ccx+arm,ccy);
  ectx.moveTo(ccx,ccy-arm);ectx.lineTo(ccx,ccy+arm);
  ectx.stroke();
}
function nearRRectCorner(ix,iy){
  if(!rRect)return null;
  const hs=Math.max(22,30/edSc);
  const{x,y,w,h}=rRect;
  const pts=[['tl',x,y],['tr',x+w,y],['bl',x,y+h],['br',x+w,y+h]];
  for(const[n,cx,cy]of pts) if(Math.abs(ix-cx)<hs&&Math.abs(iy-cy)<hs) return n;
  return null;
}
function moveRRectCorner(name,ix,iy){
  if(!rRect)return;
  const r=rRect;
  if(name==='tl'){r.w+=r.x-ix;r.h+=r.y-iy;r.x=ix;r.y=iy;}
  else if(name==='tr'){r.w=ix-r.x;r.h+=r.y-iy;r.y=iy;}
  else if(name==='bl'){r.w+=r.x-ix;r.x=ix;r.h=iy-r.y;}
  else if(name==='br'){r.w=ix-r.x;r.h=iy-r.y;}
  // clamp
  if(r.w<0){r.x+=r.w;r.w=Math.abs(r.w);}
  if(r.h<0){r.y+=r.h;r.h=Math.abs(r.h);}
}
function isInsideRRect(ix,iy){
  if(!rRect)return false;
  return ix>=rRect.x&&ix<=rRect.x+rRect.w&&iy>=rRect.y&&iy<=rRect.y+rRect.h;
}
function commitRRect(){
  if(!rRect)return;
  const r={...rRect};
  rRect=null;
  const src=history[history.length-1]||pages[edIdx].cur;
  const img=new Image();
  img.onload=()=>{
    const c=document.createElement('canvas');
    c.width=img.width;c.height=img.height;
    const ctx=c.getContext('2d');ctx.drawImage(img,0,0);
    ctx.fillStyle='#ffffff';
    ctx.fillRect(Math.round(r.x),Math.round(r.y),Math.round(r.w),Math.round(r.h));
    const newUrl=c.toDataURL('image/jpeg',0.92);
    history.push(newUrl);
    redrawEc(newUrl);
  };
  img.src=src;
}
function drawLive(ix0,iy0,ix1,iy1){
  // Coords already in image pixels
  const sx=Math.min(ix0,ix1),sy=Math.min(iy0,iy1);
  const sw=Math.abs(ix1-ix0),sh=Math.abs(iy1-iy0);
  if(tool==='redact'){
    ectx.fillStyle='rgba(255,255,255,.45)';ectx.fillRect(sx,sy,sw,sh);
  }else if(tool==='crop'){
    ectx.strokeStyle='#1a2a4a';ectx.lineWidth=Math.max(2,3/edSc);ectx.setLineDash([10,5]);
    ectx.strokeRect(sx,sy,sw,sh);ectx.setLineDash([]);
  }
}

/* Touch */
ec.addEventListener('touchstart',e=>{
  e.preventDefault();
  if(e.touches.length===2){
    // Pinch start
    const t0=e.touches[0],t1=e.touches[1];
    pinch0=Math.hypot(t0.clientX-t1.clientX,t0.clientY-t1.clientY);
    pinchMidX=(t0.clientX+t1.clientX)/2;
    pinchMidY=(t0.clientY+t1.clientY)/2;
    drawing=false; dragCorner=null; panStart=null; vpanStart=null;
    return;
  }
  const p=canvasPt(e.touches[0].clientX,e.touches[0].clientY);
  // redactRect handles
  if(tool==='redactRect'){
    rRectDragCorner=nearRRectCorner(p.x,p.y);
    if(rRectDragCorner) return;
    if(rRect && isInsideRRect(p.x,p.y)){
      rRectPanStart={x:p.x,y:p.y};
      rRectAtPan={...rRect};
      return;
    }
    rRect=null; drawing=true; px0=p.x; py0=p.y; px1=p.x; py1=p.y;
    return;
  }
  dragCorner=nearQuadCorner(p.x,p.y);
  if(dragCorner){ dragEdge=null; return; }
  dragEdge=nearEdgeMid(p.x,p.y);
  if(dragEdge){ return; }
  if(quad && tool==='crop' && isInsideQuad(p.x,p.y)){
    panStart={x:p.x,y:p.y};
    quadAtPanStart={tl:{...quad.tl},tr:{...quad.tr},bl:{...quad.bl},br:{...quad.br}};
    return;
  }
  if(tool==='none'){
    vpanStart={x:e.touches[0].clientX,y:e.touches[0].clientY};
    vXatPan=vX; vYatPan=vY;
    return;
  }
  drawing=true; px0=p.x; py0=p.y; px1=p.x; py1=p.y;
  if(tool==='redact') brushPoints=[[p.x,p.y]];
},{passive:false});

ec.addEventListener('touchmove',e=>{
  e.preventDefault();
  if(e.touches.length===2&&pinch0!==null){
    const t0=e.touches[0],t1=e.touches[1];
    const d=Math.hypot(t0.clientX-t1.clientX,t0.clientY-t1.clientY);
    const newZ=Math.max(0.5,Math.min(6,vZ*(d/pinch0)));
    const newMidX=(t0.clientX+t1.clientX)/2;
    const newMidY=(t0.clientY+t1.clientY)/2;
    // Zoom toward pinch midpoint
    vX += (newMidX-pinchMidX) + (newMidX - (parseFloat(ec.style.left)||0) - parseFloat(ec.style.width)/2) * (newZ/vZ-1);
    vY += (newMidY-pinchMidY) + (newMidY - (parseFloat(ec.style.top)||0)  - parseFloat(ec.style.height)/2) * (newZ/vZ-1);
    vZ=newZ;
    pinch0=d; pinchMidX=newMidX; pinchMidY=newMidY;
    applyViewport(); return;
  }
  if(vpanStart){
    vX=vXatPan+(e.touches[0].clientX-vpanStart.x);
    vY=vYatPan+(e.touches[0].clientY-vpanStart.y);
    applyViewport(); return;
  }
  if(rRectDragCorner){
    const p=canvasPt(e.touches[0].clientX,e.touches[0].clientY);
    moveRRectCorner(rRectDragCorner,p.x,p.y);redrawEc();return;
  }
  if(rRectPanStart){
    const p=canvasPt(e.touches[0].clientX,e.touches[0].clientY);
    const dx=p.x-rRectPanStart.x,dy=p.y-rRectPanStart.y;
    rRect={x:rRectAtPan.x+dx,y:rRectAtPan.y+dy,w:rRectAtPan.w,h:rRectAtPan.h};
    redrawEc();return;
  }
  if(dragCorner){
    const p=canvasPt(e.touches[0].clientX,e.touches[0].clientY);
    moveQuadCorner(dragCorner,p.x,p.y);redrawEc();return;
  }
  if(dragEdge){
    const p=canvasPt(e.touches[0].clientX,e.touches[0].clientY);
    moveEdgeMid(dragEdge,p.x,p.y);redrawEc();return;
  }
  if(panStart&&quadAtPanStart){
    const p=canvasPt(e.touches[0].clientX,e.touches[0].clientY);
    const dx=p.x-panStart.x,dy=p.y-panStart.y;
    quad={
      tl:{x:quadAtPanStart.tl.x+dx,y:quadAtPanStart.tl.y+dy},
      tr:{x:quadAtPanStart.tr.x+dx,y:quadAtPanStart.tr.y+dy},
      bl:{x:quadAtPanStart.bl.x+dx,y:quadAtPanStart.bl.y+dy},
      br:{x:quadAtPanStart.br.x+dx,y:quadAtPanStart.br.y+dy},
    };
    redrawEc();return;
  }
  if(drawing){
    const p=canvasPt(e.touches[0].clientX,e.touches[0].clientY);
    px1=p.x;py1=p.y;
    if(tool==='redact'){ brushPoints.push([p.x,p.y]); drawBrushLive(p.x,p.y); }
    else if(tool==='redactRect'){
      rRect={x:Math.min(px0,px1),y:Math.min(py0,py1),w:Math.abs(px1-px0),h:Math.abs(py1-py0)};
      redrawEc();
    }
    else{ redrawEc();drawLive(px0,py0,px1,py1); }
  }
},{passive:false});

ec.addEventListener('touchend',e=>{
  pinch0=null; vpanStart=null;
  dragCorner=null; dragEdge=null;
  panStart=null; quadAtPanStart=null;
  rRectDragCorner=null; rRectPanStart=null;
  if(!drawing)return; drawing=false;
  const rw=Math.abs(px1-px0),rh=Math.abs(py1-py0);
  if(rw<5||rh<5)return;
  if(tool==='redact') commitBrushStroke();
  else if(tool==='redactRect'){
    rRect={x:Math.min(px0,px1),y:Math.min(py0,py1),w:rw,h:rh};
    redrawEc();
  }
  else if(tool==='crop'){
    quad=rectToQuad(Math.min(px0,px1),Math.min(py0,py1),rw,rh);
    cropRect=null; redrawEc();
  }
},{passive:false});

/* Mouse */
ec.addEventListener('mousedown',e=>{
  const p=canvasPt(e.clientX,e.clientY);
  if(tool==='redactRect'){
    rRectDragCorner=nearRRectCorner(p.x,p.y);
    if(rRectDragCorner) return;
    if(rRect && isInsideRRect(p.x,p.y)){
      rRectPanStart={x:p.x,y:p.y}; rRectAtPan={...rRect}; return;
    }
    rRect=null; drawing=true; px0=p.x; py0=p.y; px1=p.x; py1=p.y; return;
  }
  dragCorner=nearQuadCorner(p.x,p.y);
  if(dragCorner){ dragEdge=null; return; }
  dragEdge=nearEdgeMid(p.x,p.y);
  if(dragEdge) return;
  if(quad && tool==='crop' && isInsideQuad(p.x,p.y)){
    panStart={x:p.x,y:p.y};
    quadAtPanStart={tl:{...quad.tl},tr:{...quad.tr},bl:{...quad.bl},br:{...quad.br}};
  } else if(tool==='none'){
    vpanStart={x:e.clientX,y:e.clientY}; vXatPan=vX; vYatPan=vY;
  } else {
    panStart=null;
    drawing=true;px0=p.x;py0=p.y;px1=p.x;py1=p.y;
    if(tool==='redact')brushPoints=[[p.x,p.y]];
  }
});
ec.addEventListener('mousemove',e=>{
  if(vpanStart){
    vX=vXatPan+(e.clientX-vpanStart.x);
    vY=vYatPan+(e.clientY-vpanStart.y);
    applyViewport();return;
  }
  if(!drawing&&!dragCorner&&!dragEdge&&!panStart&&!rRectDragCorner&&!rRectPanStart)return;
  const p=canvasPt(e.clientX,e.clientY);
  if(rRectDragCorner){moveRRectCorner(rRectDragCorner,p.x,p.y);redrawEc();return;}
  if(rRectPanStart){
    const dx=p.x-rRectPanStart.x,dy=p.y-rRectPanStart.y;
    rRect={x:rRectAtPan.x+dx,y:rRectAtPan.y+dy,w:rRectAtPan.w,h:rRectAtPan.h};
    redrawEc();return;
  }
  if(dragCorner){moveQuadCorner(dragCorner,p.x,p.y);redrawEc();return;}
  if(dragEdge){moveEdgeMid(dragEdge,p.x,p.y);redrawEc();return;}
  if(panStart&&quadAtPanStart){
    const dx=p.x-panStart.x,dy=p.y-panStart.y;
    quad={
      tl:{x:quadAtPanStart.tl.x+dx,y:quadAtPanStart.tl.y+dy},
      tr:{x:quadAtPanStart.tr.x+dx,y:quadAtPanStart.tr.y+dy},
      bl:{x:quadAtPanStart.bl.x+dx,y:quadAtPanStart.bl.y+dy},
      br:{x:quadAtPanStart.br.x+dx,y:quadAtPanStart.br.y+dy},
    };
    redrawEc();return;
  }
  px1=p.x;py1=p.y;
  if(tool==='redact'){ brushPoints.push([p.x,p.y]); drawBrushLive(p.x,p.y); }
  else if(tool==='redactRect'){
    rRect={x:Math.min(px0,px1),y:Math.min(py0,py1),w:Math.abs(px1-px0),h:Math.abs(py1-py0)};
    redrawEc();
  }
  else{ redrawEc();drawLive(px0,py0,px1,py1); }
});
ec.addEventListener('mouseup',e=>{
  dragCorner=null;
  if(!drawing)return;drawing=false;
  const rw=Math.abs(px1-px0),rh=Math.abs(py1-py0);
  if(rw<5||rh<5)return;
  panStart=null; quadAtPanStart=null; vpanStart=null; dragEdge=null;
  rRectDragCorner=null; rRectPanStart=null;
  if(tool==='redact')commitBrushStroke();
  else if(tool==='redactRect'){
    rRect={x:Math.min(px0,px1),y:Math.min(py0,py1),w:rw,h:rh};
    redrawEc();
  }
  else if(tool==='crop'){
    quad=rectToQuad(Math.min(px0,px1),Math.min(py0,py1),rw,rh);
    cropRect=null;redrawEc();
  }
});



/* ‚ïê‚ïê‚ïê DESKTOP SCROLL ZOOM ‚ïê‚ïê‚ïê */
document.getElementById('edCanvasArea').addEventListener('wheel',e=>{
  e.preventDefault();
  const delta=e.deltaY>0?0.9:1.1;
  const newZ=Math.max(0.3,Math.min(8,vZ*delta));
  const area=document.getElementById('edCanvasArea');
  const r=area.getBoundingClientRect();
  const mx=e.clientX-r.left, my=e.clientY-r.top;
  vX+=(mx-vX)*(1-newZ/vZ);
  vY+=(my-vY)*(1-newZ/vZ);
  vZ=newZ;
  applyViewport();
},{passive:false});

/* ‚ïê‚ïê‚ïê PDF ‚ïê‚ïê‚ïê */
function openPDFModal(){document.getElementById('pdfModal').classList.add('open');}
function closePDFModal(){document.getElementById('pdfModal').classList.remove('open');}
function setQ(el){
  document.querySelectorAll('.q-btn').forEach(b=>b.classList.remove('active'));
  el.classList.add('active');pdfQ=parseFloat(el.dataset.q);
}
function showPdfSt(msg,type){
  const el=document.getElementById('pdfSt');
  el.textContent=msg;el.className='st show '+type;
  setTimeout(()=>el.className='st',4000);
}
function exportPDF(){
  if(!pages.length)return;
  const name=(document.getElementById('pdfName').value.trim()||'document')+'.pdf';
  showPdfSt('Generating‚Ä¶','info');
  try{
    const{jsPDF}=window.jspdf;
    const a4w=595.28,a4h=841.89;
    let doc=null;
    let i=0;
    function next(){
      if(i>=pages.length){
        doc.save(name);
        showPdfSt('‚úì Saved: '+name,'ok');
        setTimeout(closePDFModal,1500);
        return;
      }
      const pg=pages[i++];
      const img=new Image();
      img.onload=()=>{
        const iw=img.naturalWidth,ih=img.naturalHeight;
        const land=iw>ih;
        // Page size matches image aspect ratio exactly ‚Äî no white padding
        const fmt=[iw,ih]; // custom page size in pixels ‚Üí convert to pt (1px=0.75pt)
        const ptW=iw*0.75, ptH=ih*0.75;
        if(!doc)doc=new jsPDF({orientation:land?'l':'p',unit:'pt',format:[ptW,ptH]});
        else doc.addPage([ptW,ptH],land?'l':'p');
        const q=pdfQ<1?'JPEG':'JPEG';
        doc.addImage(pg.cur,pg.cur.startsWith('data:image/png')?'PNG':'JPEG',0,0,ptW,ptH,undefined,pdfQ<0.9?'FAST':'NONE');
        next();
      };
      img.onerror=()=>next();
      img.src=pg.cur;
    }
    next();
  }catch(e){console.error(e);showPdfSt('Error: '+e.message,'err');}
}
</script>
</body>
</html>
